%{
/*
 * This is the YACC (Parser) file.
 * It defines the grammar rules for valid loop structures.
 */
#include <stdio.h>
#include <stdlib.h>

extern int yylex();     /* The lexer function generated by Lex */
extern int yylineno;  /* The line number from the lexer */
extern FILE *yyin; /* The input file for the lexer */

/* Function to report errors */
void yyerror(const char *s);
%}

/* --- Token Declarations --- */
/* These are the tokens we get from our Lexer */
%token FOR
%token ID
%token NUMBER

/* Relational operators and inc/dec */
%token T_EQ T_NEQ T_LTE T_GTE T_INC T_DEC

/* * Single-character tokens like '(', ')', ';', etc.
 * don't need to be declared. We can use them directly.
 */

/* --- Grammar Start Symbol --- */
%start program

%%
/* --- Grammar Rules --- */

/* A program is a list of statements */
program: statements {
            printf("\n[SUCCESS] Parsing complete. Input is a valid program.\n");
            YYACCEPT;
         };

/* 'statements' can be empty, or a list of one or more statements */
statements: /* empty */
          | statements statement
          ;

/* A 'statement' can be a for loop, an assignment, or just an empty semicolon */
statement: for_loop
         | assignment_statement
         | ';'
         ;

/* * Rule for a full 'for' loop:
 * for ( init ; condition ; update ) block
 */
for_loop: FOR '(' init ';' condition ';' update ')' block
        ;

/* The 'init' part of a for loop (e.g., i = 0) */
init: assignment
    | /* empty */
    ;

/* The 'condition' part (e.g., i < 10) */
condition: expression rel_op expression
         | /* empty */
         ;

/* The 'update' part (e.g., i++ or i = i + 1) */
/* (Note: Our expression rule is simple, so we'll just re-use 'assignment') */
update: assignment
      | ID T_INC
      | ID T_DEC
      | /* empty */
      ;

/* A block of code: either a single statement or multiple statements in {} */
/* This is the rule that allows for NESTING */
block: statement
     | '{' statements '}'
     ;

/* A standalone assignment statement (must end with a semicolon) */
assignment_statement: ID '=' expression ';'
                    ;

/* An assignment (no semicolon, for use inside the for loop) */
assignment: ID '=' expression
          ;

/* A simple expression: just an ID or a NUMBER */
expression: ID
          | NUMBER
          ;

/* Relational operator group */
rel_op: T_EQ
      | T_NEQ
      | T_LTE
      | T_GTE
      | '<'
      | '>'
      ;

%%

/* --- C Code Section --- */

/* New main function that accepts command-line arguments */
int main(int argc, char *argv[]) {
    
    /* Check if a filename was provided as an argument */
    if (argc > 1) {
        FILE *file = fopen(argv[1], "r");
        if (!file) {
            fprintf(stderr, "Error: Could not open file '%s'\n", argv[1]);
            return 1;
        }
        yyin = file; /* Tell the lexer to read from this file */
    } else {
        /* No file provided, read from standard input (keyboard) */
        printf("Enter code to validate. Press Ctrl+D when done.\n");
        printf("------------------------------------------------\n");
    }

    /* Run the parser */
    if (yyparse() == 0) {
        /* yyparse() returns 0 on success */
    } else {
        printf("\n[FAILURE] Parsing failed.\n");
    }

    return 0;
}

/* Custom error reporting function */
void yyerror(const char *s) {
    /* 's' is the error message from YACC (usually "syntax error") */
    fprintf(stderr, "[ERROR] Line %d: %s\n", yylineno, s);
}
